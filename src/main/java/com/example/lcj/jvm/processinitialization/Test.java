package com.example.lcj.jvm.processinitialization;

/**
 * 在准备阶段，变量已经赋过一次系统要求的初始值(零值)；
 * 而在初始化阶段，则根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，
 * 或者更直接地说：初始化阶段是执行类构造器<clinit>()方法的过程。
 * <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的，
 * 编译器收集的顺序是由语句在源文件中出现的顺序所决定的，
 * 静态语句块只能访问到定义在静态语句块之前的变量，
 * 定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问
 */
public class Test{
    static{
        i=0;
        //System.out.println(i);//Error：Cannot reference a field before it is defined（非法向前应用）
    }
    static int i=1;
}

/**
 * 类构造器<clinit>()与实例构造器<init>()不同，
 * 它不需要程序员进行显式调用，虚拟机会保证在子类类构造器<clinit>()执行之前，
 * 父类的类构造<clinit>()执行完毕。
 * 由于父类的构造器<clinit>()先执行，
 * 也就意味着父类中定义的静态语句块/静态变量的初始化要优先于子类的静态语句块/静态变量的初始化执行。
 * 特别地，类构造器<clinit>()对于类或者接口来说并不是必需的，
 * 如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生产类构造器<clinit>()。
 */

/**
 * 虚拟机会保证一个类的类构造器<clinit>()在多线程环境中被正确的加锁、同步，
 * 如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的类构造器<clinit>()，
 * 其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。
 * 特别需要注意的是，在这种情形下，其他线程虽然会被阻塞，
 * 但如果执行<clinit>()方法的那条线程退出后，
 * 其他线程在唤醒之后不会再次进入/执行<clinit>()方法，因为 在同一个类加载器下，一个类型只会被初始化一次。
 */

